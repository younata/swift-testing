//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for Swift project authors
//

@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
internal let defaultPollingConfiguration = (
  maxPollingIterations: 1000,
  pollingInterval: Duration.milliseconds(1)
)

/// Confirm that some expression eventually returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@_spi(Experimental)
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmPassesEventually(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async {
  let poller = Poller(
    pollingBehavior: .passesOnce,
    pollingIterations: getValueFromPollingTrait(
      providedValue: maxPollingIterations,
      default: defaultPollingConfiguration.maxPollingIterations,
      \ConfirmPassesEventuallyConfigurationTrait.maxPollingIterations
    ),
    pollingInterval: getValueFromPollingTrait(
      providedValue: pollingInterval,
      default: defaultPollingConfiguration.pollingInterval,
      \ConfirmPassesEventuallyConfigurationTrait.pollingInterval
    ),
    comment: comment,
    sourceLocation: sourceLocation
  )
  await poller.evaluate(isolation: isolation) {
    do {
      return try await body()
    } catch {
      return false
    }
  }
}

/// A type describing an error thrown when polling fails to return a non-nil
/// value
@_spi(Experimental)
public struct PollingFailedError: Error {}

/// Confirm that some expression eventually returns a non-nil value
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or
///     suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmPassesEventuallyConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmPassesEventuallyConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// - Returns: The first non-nil value returned by `body`.
///
/// - Throws: A `PollingFailedError` will be thrown if `body` never returns a
///   non-optional value
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, waiting on some state to change that cannot be easily confirmed
/// through other forms of `confirmation`.
@_spi(Experimental)
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
@discardableResult
public func confirmPassesEventually<R>(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> R?
) async throws -> R where R: Sendable {
  let recorder = PollingRecorder<R>()
  let poller = Poller(
    pollingBehavior: .passesOnce,
    pollingIterations: getValueFromPollingTrait(
      providedValue: maxPollingIterations,
      default: defaultPollingConfiguration.maxPollingIterations,
      \ConfirmPassesEventuallyConfigurationTrait.maxPollingIterations
    ),
    pollingInterval: getValueFromPollingTrait(
      providedValue: pollingInterval,
      default: defaultPollingConfiguration.pollingInterval,
      \ConfirmPassesEventuallyConfigurationTrait.pollingInterval
    ),
    comment: comment,
    sourceLocation: sourceLocation
  )
  await poller.evaluate(isolation: isolation) {
    do {
      return try await recorder.record(value: body())
    } catch {
      return false
    }
  }

  if let value = await recorder.lastValue {
    return value
  }
  throw PollingFailedError()
}

/// Confirm that some expression always returns true
///
/// - Parameters:
///   - comment: An optional comment to apply to any issues generated by this
///     function.
///   - maxPollingIterations: The maximum amount of times to attempt polling.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will be attempted 1000 times before recording an issue.
///     `maxPollingIterations` must be greater than 0.
///   - pollingInterval: The minimum amount of time to wait between polling
///     attempts.
///     If nil, this uses whatever value is specified under the last
///     ``ConfirmAlwaysPassesConfigurationTrait`` added to the test or suite.
///     If no ``ConfirmAlwaysPassesConfigurationTrait`` has been added, then
///     polling will wait at least 1 millisecond between polling attempts.
///     `pollingInterval` must be greater than 0.
///   - isolation: The actor to which `body` is isolated, if any.
///   - sourceLocation: The source location to whych any recorded issues should
///     be attributed.
///   - body: The function to invoke.
///
/// Use polling confirmations to check that an event while a test is running in
/// complex scenarios where other forms of confirmation are insufficient. For
/// example, confirming that some state does not change.
@_spi(Experimental)
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
public func confirmAlwaysPasses(
  _ comment: Comment? = nil,
  maxPollingIterations: Int? = nil,
  pollingInterval: Duration? = nil,
  isolation: isolated (any Actor)? = #isolation,
  sourceLocation: SourceLocation = #_sourceLocation,
  _ body: @escaping () async throws -> Bool
) async {
  let poller = Poller(
    pollingBehavior: .passesAlways,
    pollingIterations: getValueFromPollingTrait(
      providedValue: maxPollingIterations,
      default: defaultPollingConfiguration.maxPollingIterations,
      \ConfirmAlwaysPassesConfigurationTrait.maxPollingIterations
    ),
    pollingInterval: getValueFromPollingTrait(
      providedValue: pollingInterval,
      default: defaultPollingConfiguration.pollingInterval,
      \ConfirmAlwaysPassesConfigurationTrait.pollingInterval
    ),
    comment: comment,
    sourceLocation: sourceLocation
  )
  await poller.evaluate(isolation: isolation) {
    do {
      return try await body()
    } catch {
      return false
    }
  }
}

/// A helper function to de-duplicate the logic of grabbing configuration from
/// either the passed-in value (if given), the hardcoded default, and the
/// appropriate configuration trait.
///
/// The provided value, if non-nil is returned. Otherwise, this looks for
/// the last `TraitKind` specified, and if one exists, returns the value
/// as determined by `keyPath`.
/// If no configuration trait has been applied, then this returns the `default`.
///
/// - Parameters:
///   - providedValue: The value provided by the test author when calling
///     `confirmPassesEventually` or `confirmAlwaysPasses`.
///   - default: The harded coded default value, as defined in
///     `defaultPollingConfiguration`
///   - keyPath: The keyPath mapping from `TraitKind` to the desired value type.
private func getValueFromPollingTrait<TraitKind, Value>(
  providedValue: Value?,
  default: Value,
  _ keyPath: KeyPath<TraitKind, Value?>
) -> Value {
  if let providedValue { return providedValue }
  guard let test = Test.current else { return `default` }
  let possibleTraits = test.traits.compactMap { $0 as? TraitKind }
  let traitValues = possibleTraits.compactMap { $0[keyPath: keyPath] }
  return traitValues.last ?? `default`
}

/// A type to record the last value returned by a closure returning an optional
/// This is only used in the `confirm` polling functions evaluating an optional.
private actor PollingRecorder<R: Sendable> {
  var lastValue: R?

  /// Record a new value to be returned
  func record(value: R) {
    self.lastValue = value
  }

  func record(value: R?) -> Bool {
    if let value {
      self.lastValue = value
      return true
    } else {
      return false
    }
  }
}

/// A type for managing polling
@available(macOS 13, iOS 17, watchOS 9, tvOS 17, visionOS 1, *)
private struct Poller {
  enum PollingBehavior {
    /// Continuously evaluate the expression until the first time it returns
    /// true.
    /// If it does not pass once by the time the timeout is reached, then a
    /// failure will be reported.
    case passesOnce

    /// Continuously evaluate the expression until the first time it returns
    /// false.
    /// If the expression returns false, then a failure will be reported.
    /// If the expression only returns true before the timeout is reached, then
    /// no failure will be reported.
    /// If the expression does not finish evaluating before the timeout is
    /// reached, then a failure will be reported.
    case passesAlways

    /// Process the result of a polled expression and decide whether to continue polling.
    ///
    /// - Parameters:
    ///   - expressionResult: The result of the polled expression
    ///
    /// - Returns: A poll result (if polling should stop), or nil (if polling should continue)
    func processFinishedExpression(
      expressionResult result: Bool
    ) -> PollResult? {
      switch self {
      case .passesOnce:
        if result {
          return .finished
        } else {
          return nil
        }
      case .passesAlways:
        if !result {
          return .failed
        } else {
          return nil
        }
      }
    }
  }

  /// The result of polling expressions
  enum PollResult {
    /// The polling ran for the total number of iterations
    case ranToCompletion
    /// The expression exited early, and we will report a success status.
    case finished
    /// The expression returned false under PollingBehavior.passesAlways
    case failed
    /// The polling was cancelled before polling could finish
    case cancelled

    /// Process the poll result into an issue
    ///
    /// - Parameters:
    ///   - comment: The comment to record as part of the issue
    ///   - sourceContext: The source context for the issue
    ///   - pollingBehavior: The polling behavior used.
    /// - Returns: An issue if one should be recorded, otherwise nil.
    func issue(
      comment: Comment?,
      sourceContext: SourceContext,
      pollingBehavior: PollingBehavior
    ) -> Issue? {
      let issueKind: Issue.Kind
      switch self {
      case .finished, .cancelled:
        return nil
      case .ranToCompletion:
        if case .passesAlways = pollingBehavior {
          return nil
        }
        issueKind = .confirmationPollingFailed
      case .failed:
        issueKind = .confirmationPollingFailed
      }
      return Issue(
        kind: issueKind,
        comments: Array(comment),
        sourceContext: sourceContext
      )
    }
  }

  /// The polling behavior (poll until the expression first passes, or poll
  /// while the expression continues to pass)
  let pollingBehavior: PollingBehavior

  // How many times to poll
  let pollingIterations: Int
  // Minimum waiting period between polling
  let pollingInterval: Duration

  /// A comment from the test author associated with the polling
  let comment: Comment?

  /// The source location that asked for polling.
  let sourceLocation: SourceLocation

  /// Evaluate polling, and process the result, raising an issue if necessary.
  ///
  /// - Parameters:
  ///   - body: The expression to poll
  /// - Side effects: If polling fails (see `PollingBehavior`), then this will
  ///   record an issue.
  func evaluate(
    isolation: isolated (any Actor)?,
    _ body: @escaping () async -> Bool
  ) async {
    precondition(pollingIterations > 0)
    precondition(pollingInterval > Duration.zero)
    let result = await poll(
      expression: body
    )
    result.issue(
      comment: comment,
      sourceContext: .init(backtrace: .current(), sourceLocation: sourceLocation),
      pollingBehavior: pollingBehavior
    )?.record()
  }

  /// This function contains the logic for continuously polling an expression,
  /// as well as processing the results of that expression
  ///
  /// - Parameters:
  ///   - expression: An expression to continuously evaluate
  ///   - behavior: The polling behavior to use
  ///   - timeout: How long to poll for unitl the timeout triggers.
  /// - Returns: The result of this polling.
  private func poll(
    isolation: isolated (any Actor)? = #isolation,
    expression: @escaping () async -> Bool
  ) async -> PollResult {
    for iteration in 0..<pollingIterations {
      if let result = await pollingBehavior.processFinishedExpression(
        expressionResult: expression()
      ) {
        return result
      }
      if iteration == (pollingIterations - 1) {
        // don't bother sleeping if it's the last iteration.
        break
      }
      do {
        try await Task.sleep(for: pollingInterval)
      } catch {
        // `Task.sleep` should only throw an error if it's cancelled
        // during the sleep period.
        return .cancelled
      }
    }
    return .ranToCompletion
  }
}
